/*
https://valentin.webverse.world/me-000-001-001
{
  "category": "me",
  "originHost": "webverseworlds.com",
  "originBase": "/hello_from_valentin1",
  "targetPath": "/"
}
*/
const CATEGORY_SEPARATOR = "-";
const DISCRIMINATOR_REGEX = /^\d{3}-\d{3}-\d{3}$/;

// ---- helpers ----
function escapeRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function stripAnchors(regexSource) {
  return regexSource.replace(/^\^/, "").replace(/\$$/, "");
}
function extractWorldName(host) {
  host = host.toLowerCase();
  if (!host.endsWith(".webverse.world")) return null;
  const label = host.slice(0, -".webverse.world".length);
  if (!label || label === "*" || label === "webverse") return null;
  return label;
}
function extractFromFirstSeg(pathname) {
  const firstSeg = pathname.split("/").filter(Boolean)[0];
  if (!firstSeg) return { category: null, disc: null, mode: null };

  if (DISCRIMINATOR_REGEX.test(firstSeg)) {
    return { category: null, disc: firstSeg, mode: "discOnly" };
  }

  const sep = escapeRegex(CATEGORY_SEPARATOR);
  const discPattern = stripAnchors(DISCRIMINATOR_REGEX.source);
  const re = new RegExp(`^(.*)${sep}(${discPattern})$`);
  const match = firstSeg.match(re);
  if (!match) return { category: null, disc: null, mode: null };

  const category = match[1] || null;
  const disc = match[2] || null;

  if (!disc || !DISCRIMINATOR_REGEX.test(disc)) {
    return { category: null, disc: null, mode: null };
  }
  return { category, disc, mode: "categoryDisc" };
}

function isProbablyHtmlNavigation(request) {
  if (request.method !== "GET") return false;
  const accept = request.headers.get("accept") || "";
  return accept.includes("text/html");
}
function isHtmlResponse(resp) {
  const ct = resp.headers.get("content-type") || "";
  return ct.includes("text/html");
}

function joinPath(...parts) {
  const cleaned = parts
    .filter((p) => p != null && p !== "")
    .map((p) => String(p));

  let out = "";
  for (const p of cleaned) {
    if (!out) out = p;
    else out = out.replace(/\/+$/, "") + "/" + p.replace(/^\/+/, "");
  }
  if (!out.startsWith("/")) out = "/" + out;
  return out;
}

function canonicalizeUrlKeepingRest(requestUrl, canonicalFirstSeg) {
  const fixed = new URL(requestUrl);
  const parts = fixed.pathname.split("/").filter(Boolean);
  if (parts.length === 0) {
    fixed.pathname = `/${canonicalFirstSeg}`;
    return fixed;
  }
  parts[0] = canonicalFirstSeg;
  fixed.pathname = "/" + parts.join("/");
  return fixed;
}

function injectCanonical(html, canonicalUrl) {
  html = html.replace(/<link\s+rel=["']canonical["'][^>]*>\s*/gi, "");
  if (/<\/head>/i.test(html)) {
    return html.replace(
      /<\/head>/i,
      `  <link rel="canonical" href="${canonicalUrl}">\n</head>`
    );
  }
  return `<head><link rel="canonical" href="${canonicalUrl}"></head>${html}`;
}

function upsertRobotsDirectives(html, { robotsMeta, googlebotMeta } = {}) {
  html = html
    .replace(/<meta\s+name=["']robots["'][^>]*>\s*/gi, "")
    .replace(/<meta\s+name=["']googlebot["'][^>]*>\s*/gi, "");

  const injections = [
    robotsMeta ? `<meta name="robots" content="${robotsMeta}">` : "",
    googlebotMeta ? `<meta name="googlebot" content="${googlebotMeta}">` : "",
  ]
    .filter(Boolean)
    .join("\n  ");

  if (!injections) return html;

  if (/<head[^>]*>/i.test(html)) {
    return html.replace(/<head[^>]*>/i, (m) => `${m}\n  ${injections}`);
  }
  if (/<\/head>/i.test(html)) {
    return html.replace(/<\/head>/i, `  ${injections}\n</head>`);
  }
  return `<head>${injections}</head>${html}`;
}

/**
 * SECURITY: prevent becoming an open proxy.
 * You can tighten this later (allowlist of domains, require https, block private IPs, etc.).
 */
function validateOriginUrl(originUrl) {
  let u;
  try {
    u = new URL(originUrl);
  } catch {
    return { ok: false, reason: "originUrl is not a valid URL" };
  }
  if (u.protocol !== "https:") return { ok: false, reason: "originUrl must be https" };
  return { ok: true, url: u };
}

export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    // ✅ Worker-owned robots.txt (your canonical domain policy)
    if (url.pathname === "/robots.txt") {
      return new Response(`User-agent: *
Allow: /
`, {
        status: 200,
        headers: {
          "content-type": "text/plain; charset=UTF-8",
          "cache-control": "public, max-age=3600",
        },
      });
    }

    const worldName = extractWorldName(url.hostname);
    if (!worldName) return new Response("Not found", { status: 404 });

    const { disc, mode } = extractFromFirstSeg(url.pathname);
    if (!disc) return new Response("World discriminator missing", { status: 404 });

    const key = `${worldName}#${disc}`;
    const raw = await env.WORLDS.get(key);
    if (!raw) return new Response("World not registered", { status: 404 });

    let cfg;
    try {
      cfg = JSON.parse(raw);
    } catch {
      return new Response("Bad registry entry", { status: 500 });
    }

    // ✅ canonical category/segment
    const canonicalCategory = (cfg.category || "me").trim() || "me";
    const canonicalFirstSeg = `${canonicalCategory}${CATEGORY_SEPARATOR}${disc}`;

    // Parse request restPath after first segment
    const parts = url.pathname.split("/").filter(Boolean);
    const restPath = parts.length > 1 ? "/" + parts.slice(1).join("/") : "/";

    // ✅ canonical redirect (only for HTML navigations)
    if (isProbablyHtmlNavigation(request)) {
      const firstSeg = parts[0] || "";
      const isDiscOnly = mode === "discOnly";
      const isCategoryNotCanonical = mode === "categoryDisc" && firstSeg !== canonicalFirstSeg;

      if (isDiscOnly || isCategoryNotCanonical) {
        const fixed = canonicalizeUrlKeepingRest(url.toString(), canonicalFirstSeg);
        return Response.redirect(fixed.toString(), 308);
      }
    }

    // ✅ originUrl (works for ANY user-deployed website)
    const originUrlRaw = (cfg.originUrl || "").trim();
    if (!originUrlRaw) return new Response("Missing originUrl in registry", { status: 500 });

    const check = validateOriginUrl(originUrlRaw);
    if (!check.ok) return new Response(`Bad originUrl: ${check.reason}`, { status: 500 });

    const originBase = check.url; // e.g. https://my-site.netlify.app
    const originBasePath = (cfg.originBasePath || "").trim(); // optional subfolder on origin

    // Build target URL on origin:
    // origin pathname = originBasePath + restPath
    const target = new URL(originBase.toString());
    target.pathname = joinPath(originBasePath, restPath);
    target.search = url.search;

    // Proxy request (avoid GET/HEAD body)
    const headers = new Headers(request.headers);
    headers.delete("host"); // let fetch set correct host for origin
    // Optional: drop accept-encoding so CF can decode and you can rewrite HTML reliably
    // headers.delete("accept-encoding");

    const init = {
      method: request.method,
      headers,
      redirect: "follow",
    };
    if (request.method !== "GET" && request.method !== "HEAD") {
      init.body = request.body;
    }

    let resp = await fetch(target.toString(), init);

    // If HTML, inject canonical + make indexable on Worker domain
    if (isHtmlResponse(resp)) {
      const canonicalUrl = `${url.origin}/${canonicalFirstSeg}` + (restPath === "/" ? "" : restPath);

      let html = await resp.text();
      html = injectCanonical(html, canonicalUrl);

      // Worker-served page should be indexable
      const ROBOTS_META = "index, follow";
      const GOOGLEBOT_META =
        "index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1";

      html = upsertRobotsDirectives(html, {
        robotsMeta: ROBOTS_META,
        googlebotMeta: GOOGLEBOT_META,
      });

      const outHeaders = new Headers(resp.headers);
      outHeaders.delete("content-length");

      // Strong crawler directive at HTTP level
      outHeaders.set("X-Robots-Tag", "index, follow");

      return new Response(html, { status: resp.status, headers: outHeaders });
    }

    return resp;
  },
};
